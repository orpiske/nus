// LICENSE: (Please see the file COPYING for details)
//
// NUS - Nemesis Utilities System: A C++ application development framework 
// Copyright (C) 2006, 2008 Otavio Rodolfo Piske
//
//  This file is part of NUS
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation version 2.1
//  of the License.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
//
#include "nproj.h"


NProj::NProj(void)
	: NObject(),
	m_modules(),
	m_exe_name(),
	m_exe_files(),
	m_lib_name(),
	m_lib_files(),
	m_link_libraries(),
	m_output(),
	m_license(false),
	m_force(false)
{ 

}


NProj::~NProj(void) {

}

void NProj::addOpt(NList<NString> *list, NString &str) {
	*list = str.split(",");

	for (nuint64 i = 0; i < list->size(); i++) {
		NDebug::print() << "Added " << list->at(i);
	}

}

bool NProj::setModules(const NOpt<NProj> &opts) { 
	NString tmp;
	NList<NString> validModules;

	validModules.append("NBase");
	validModules.append("NEvents");
	validModules.append("NNetwork");
	validModules.append("NSecurity");
	validModules.append("NXml");
	validModules.append("NDBal");
	validModules.append("NMySQL");

	tmp = opts.getValues().at(0);
	addOpt(&m_modules, tmp);

	for (nuint64 i = 0; i < m_modules.size(); i++) {
		if (!validModules.contains(m_modules.at(i))) {
			NString msg;

			msg = msg + "Module " + m_modules.at(i) + " is not a "
				"valid module";
			throw NException(msg, NException::TOOLS);
		}
	}

	return true;
}


bool NProj::setExecutableFiles(const NOpt<NProj> &opts) {
	NString tmp;

	tmp = opts.getValues().at(0);
	addOpt(&m_exe_files, tmp);

	return true;
}


bool NProj::setExecutableName(const NOpt<NProj> &opts) {
	m_exe_name = opts.getValues().at(0);

	return true;
}


bool NProj::setLibraryFiles(const NOpt<NProj> &opts) {
	NString tmp;

	tmp = opts.getValues().at(0);
	addOpt(&m_lib_files, tmp);

	return true;
}


bool NProj::setLibraryName(const NOpt<NProj> &opts) {
	m_lib_name = opts.getValues().at(0);

	return true;
}


bool NProj::setLinkLibraries(const NOpt<NProj> &opts) {
	NString tmp;

	tmp = opts.getValues().at(0);
	addOpt(&m_link_libraries, tmp);

	return true;
}

bool NProj::setLicense(const NOpt<NProj> &opts) {
	m_license = true;

	return true;
}


bool NProj::setForce(const NOpt<NProj> &opts) {
	m_force = true;

	return true;
}

bool NProj::version(const NOpt<NProj> &opts) {
	NMessage::print() << "nproj " << N_TOOLS_VERSION;
	NMessage::print() << "Copyright (C) 2006, 2008 Otavio Rodolfo Piske";
	NMessage::print() << "License: GPL v2.1 " << 
		"<http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html>";
	
	NMessage::print() << "This is free software: you are free to change "
		<< "and redistribute it.";
	NMessage::print() << "There is NO WARRANTY, to the extent permitted by law.";
	NMessage::print() << "Written by Otavio Rodolfo Piske";

	return true;
}

void NProj::setupHeader(void) {
	NDataStream header;

	header = "# CMake project file for NUS\n";
	header = header + "# Generated by NProj " + N_TOOLS_VERSION 
		+ " with NUS version " + N_VERSION + "\n";

	m_output.write(header);
}

void NProj::addModules(void) {
	NDataStream tmp;

	NDebug::print() << "Number of files: " << m_exe_files.count();

	tmp = "# Project Modules\n";
	
	if (m_modules.count() == 0) {
		tmp = tmp + "INCLUDE(NBase)\n\n"; 
	}
	else {
		tmp = "";
		for (nuint64 i = 0; i < m_modules.count(); i++) {
			tmp = tmp + "INCLUDE(" + m_modules.at(i) + ")\n";
		}
	}

	tmp = tmp + "\n";
	m_output.write(tmp);
}

void NProj::addExecutable(void) {
	NDataStream tmp;

	NDebug::print() << "Number of files: " << m_exe_files.count();
	NDebug::print() << "Executable name: " << m_exe_name;
	if (m_exe_name == "" && m_exe_files.count() > 0) {
		throw NException("You provided source files for building the "
			"executable but no executable name", NException::TOOLS);
	}
	else {
		if (m_exe_name != "" && m_exe_files.count() == 0) {
			throw NException("You provided an executable name but "
				"no source files for building it", 
				NException::TOOLS);
		
		}
		else { 
			if (m_exe_name == "" && m_exe_files.count() == 0) { 
				return;
			}
		}
	}

	tmp = "# Project executable\n";
	tmp = tmp + "ADD_EXECUTABLE(\n"; 
	tmp = tmp + "\t" + m_exe_name + "\n";
	
	for (nuint64 i = 0; i < m_exe_files.size(); i++) {
		NDebug::print() << "Adding " << m_exe_files.at(i);

		tmp = tmp + "\t" + m_exe_files.at(i) + "\n";
		create_if_not_exists(m_exe_files.at(i), m_license ? NLGPL : "", 
			m_force);
	}
	tmp = tmp + ")\n\n";

	m_output.write(tmp);
}


void NProj::addLibrary(void) {
	NDataStream tmp;

	NDebug::print() << "Number of files: " << m_lib_files.count();
	NDebug::print() << "Library name: " << m_lib_name;
	if (m_lib_name == "" && m_lib_files.count() > 0) {
		throw NException("You provided source files for building the "
			"library but no library name", NException::TOOLS);
	}
	else {
		if (m_lib_name != "" && m_lib_files.count() == 0) {
			throw NException("You provided a library name but "
				"no source files for building it", 
				NException::TOOLS);
		
		}
		else { 
			if (m_lib_name == "" && m_lib_files.count() == 0) { 
				return;
			}
		}

	}

	tmp = "# Project library\n";
	tmp = tmp + "ADD_LIBRARY(\n"; 
	tmp = tmp + "\t" + m_lib_name + "\n";
	
	for (nuint64 i = 0; i < m_lib_files.size(); i++) {
		tmp = tmp + "\t" + m_lib_files.at(i) + "\n";
	}
	tmp = tmp + ")\n\n";

	m_output.write(tmp);
}


int NProj::run(void) {
	if (NFile::exists("CMakeLists.txt") && !m_force) {
		throw NException("There's already a CMakeLists.txt file in this"
			" project. Remove it before running nproj", 
			NException::TOOLS);
	}

	m_output.setFileName("CMakeLists.txt");
	m_output.open(NIODevice::Truncate);	

	setupHeader();
	addModules();
	addExecutable();
	addLibrary();

	m_output.closeDevice();
	
	return 0;
}
